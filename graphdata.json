{
  "nodes": [
    {
      "id": 0,
      "name": "python_scanner.go",
      "category": "file",
      "path": "cgitrepo/goservice/python_scanner.go",
      "content": "package main\n\nimport (\n    \"os\"\n    \"regexp\"\n)\n\n// ScanPythonScanner scans a Python file for dependency strings (imports).\nfunc ScanPythonScanner(filePath string) ([]string, error) {\n    content, err := os.ReadFile(filePath)\n    if err != nil {\n        return nil, err\n\t}\n    text := string(content)\n\n    // Match patterns like \"import module\" and \"from module import ...\"\n    reImport := regexp.MustCompile(`(?m)^(?:import|from)\\s+([\\w\\.]+)`)\n    depMap := make(map[string]bool)\n    for _, m := range reImport.FindAllStringSubmatch(text, -1) {\n        depMap[m[1]] = true\n    }\n    var deps []string\n    for dep := range depMap {\n        deps = append(deps, dep)\n    }\n    return deps, nil\n}",
      "dependencies": [
        "os",
        "regexp"
      ]
    },
    {
      "id": 1,
      "name": "file_scanner.go",
      "category": "file",
      "path": "cgitrepo/goservice/file_scanner.go",
      "content": "package main\n\nimport (\n\t\"io/fs\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Map of languages to their file extensions\nvar langExtensions = map[string][]string{\n\t\"javascript\": {\".js\", \".jsx\", \".ts\", \".tsx\"},\n\t\"python\":     {\".py\"},\n\t\"go\":         {\".go\"},\n}\n\n// FindEntryPoints walks through the repository and returns files that match known extensions.\nfunc FindEntryPoints(root string, languages []string) ([]string, error) {\n\tvar entryPoints []string\n\n\t// Build a flat list of extensions to search for.\n\tvar exts []string\n\tfor _, lang := range languages {\n\t\tif langExt, ok := langExtensions[lang]; ok {\n\t\t\texts = append(exts, langExt...)\n\t\t}\n\t}\n\n\terr := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !d.IsDir() {\n\t\t\tfor _, ext := range exts {\n\t\t\t\tif strings.HasSuffix(path, ext) {\n\t\t\t\t\tentryPoints = append(entryPoints, path)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn entryPoints, err\n}\n\n// DetectLanguages scans the repository and returns a list of detected languages.\nfunc DetectLanguages(root string) ([]string, error) {\n\tlangSet := make(map[string]bool)\n\terr := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !d.IsDir() {\n\t\t\tif strings.HasSuffix(path, \".js\") || strings.HasSuffix(path, \".ts\") ||\n\t\t\t\tstrings.HasSuffix(path, \".jsx\") || strings.HasSuffix(path, \".tsx\") {\n\t\t\t\tlangSet[\"javascript\"] = true\n\t\t\t} else if strings.HasSuffix(path, \".py\") {\n\t\t\t\tlangSet[\"python\"] = true\n\t\t\t} else if strings.HasSuffix(path, \".go\") {\n\t\t\t\tlangSet[\"go\"] = true\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar languages []string\n\tfor lang := range langSet {\n\t\tlanguages = append(languages, lang)\n\t}\n\treturn languages, nil\n}\n",
      "dependencies": [
        "io/fs",
        "path/filepath",
        "strings"
      ]
    },
    {
      "id": 2,
      "name": "go_scanner.go",
      "category": "file",
      "path": "cgitrepo/goservice/go_scanner.go",
      "content": "package main\n\nimport (\n    \"os\"\n    \"regexp\"\n)\n\n// ScanGoScanner scans a Go file for import statements with improved parsing.\nfunc ScanGoScanner(filePath string) ([]string, error) {\n    content, err := os.ReadFile(filePath)\n    if err != nil {\n        return nil, err\n    }\n    text := string(content)\n    depMap := make(map[string]bool)\n\n    // Pattern for single-line imports: import \"package\" or alias \"package\"\n    singleImportRegex := regexp.MustCompile(`import\\s+(?:\\S+\\s+)?\\\"([^\\\"]+)\\\"`)\n    matches1 := singleImportRegex.FindAllStringSubmatch(text, -1)\n    for _, match := range matches1 {\n        if match[1] != \"\" {\n            depMap[match[1]] = true\n        }\n    }\n\n    // Pattern for grouped imports: import ( ... )\n    groupImportRegex := regexp.MustCompile(`import\\s+\\(([\\s\\S]*?)\\)`)\n    matches2 := groupImportRegex.FindAllStringSubmatch(text, -1)\n    for _, m := range matches2 {\n        groupText := m[1]\n        // Each line may have an alias and a quoted package.\n        lineRegex := regexp.MustCompile(`(?:\\S+\\s+)?\\\"([^\\\"]+)\\\"`)\n        lineMatches := lineRegex.FindAllStringSubmatch(groupText, -1)\n        for _, lm := range lineMatches {\n            if lm[1] != \"\" {\n                depMap[lm[1]] = true\n            }\n        }\n    }\n\n    var deps []string\n    for dep := range depMap {\n        deps = append(deps, dep)\n    }\n    return deps, nil\n}",
      "dependencies": [
        "package",
        "regexp",
        "os"
      ]
    },
    {
      "id": 3,
      "name": "graph_builder.go",
      "category": "file",
      "path": "cgitrepo/goservice/graph_builder.go",
      "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// Node represents a node in the dependency graph.\ntype Node struct {\n\tID           int      `json:\"id\"`\n\tName         string   `json:\"name\"`\n\tCategory     string   `json:\"category\"`\n\tPath         string   `json:\"path,omitempty\"`\n\tColor        string   `json:\"color,omitempty\"`\n\tContent      string   `json:\"content,omitempty\"`\n\tDependencies []string `json:\"dependencies,omitempty\"`\n}\n\n// Link represents an edge between two nodes.\ntype Link struct {\n\tSource   int     `json:\"source\"`\n\tTarget   int     `json:\"target\"`\n\tRelation string  `json:\"relation\"`\n\tStrength float64 `json:\"strength,omitempty\"`\n}\n\n// GraphData holds all nodes and links.\ntype GraphData struct {\n\tNodes []Node `json:\"nodes\"`\n\tLinks []Link `json:\"links\"`\n}\n\n// BuildGraph constructs a graph from the dependency tree and package dependencies.\nfunc BuildGraph(depTree map[string][]string, pkgDeps map[string]bool) (GraphData, error) {\n\tvar graph GraphData\n\tfileNodeIDs := make(map[string]int)\n\tdepNodeIDs := make(map[string]int)\n\tidCounter := 0\n\n\t// Create a node for every file.\n\tfor file, deps := range depTree {\n\t\t// Read file content\n\t\tcontent, err := os.ReadFile(file)\n\t\tvar fileContent string\n\t\tif err == nil {\n\t\t\tfileContent = string(content)\n\t\t}\n\n\t\tnode := Node{\n\t\t\tID:           idCounter,\n\t\t\tName:         filepath.Base(file),\n\t\t\tCategory:     \"file\",\n\t\t\tPath:         file,\n\t\t\tContent:      fileContent,\n\t\t\tDependencies: deps,\n\t\t}\n\t\tgraph.Nodes = append(graph.Nodes, node)\n\t\tfileNodeIDs[file] = idCounter\n\t\tidCounter++\n\t}\n\n\t// Create nodes for dependencies.\n\tfor _, deps := range depTree {\n\t\tfor _, dep := range deps {\n\t\t\tif _, exists := depNodeIDs[dep]; !exists {\n\t\t\t\tcategory := \"dependency\"\n\t\t\t\tif pkgDeps != nil \u0026\u0026 pkgDeps[dep] {\n\t\t\t\t\tcategory = \"library\"\n\t\t\t\t}\n\t\t\t\tnode := Node{\n\t\t\t\t\tID:       idCounter,\n\t\t\t\t\tName:     dep,\n\t\t\t\t\tCategory: category,\n\t\t\t\t}\n\t\t\t\tgraph.Nodes = append(graph.Nodes, node)\n\t\t\t\tdepNodeIDs[dep] = idCounter\n\t\t\t\tidCounter++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Create links from file nodes to dependency nodes.\n\tfor file, deps := range depTree {\n\t\tsrcID := fileNodeIDs[file]\n\t\tfor _, dep := range deps {\n\t\t\ttargetID, ok := depNodeIDs[dep]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlink := Link{\n\t\t\t\tSource:   srcID,\n\t\t\t\tTarget:   targetID,\n\t\t\t\tRelation: \"depends\",\n\t\t\t}\n\t\t\tgraph.Links = append(graph.Links, link)\n\t\t}\n\t}\n\n\treturn graph, nil\n}\n\n// SaveGraphData writes the graph JSON to a file.\nfunc SaveGraphData(filename string, graph GraphData) error {\n\tjsonData, err := json.MarshalIndent(graph, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.WriteFile(filename, jsonData, 0644)\n}\n",
      "dependencies": [
        "encoding/json",
        "os",
        "path/filepath"
      ]
    },
    {
      "id": 4,
      "name": "jsanalysis.go",
      "category": "file",
      "path": "cgitrepo/goservice/jsanalysis.go",
      "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"regexp\"\n)\n\n// CallDetail holds details about a function call.\ntype CallDetail struct {\n\tName string `json:\"name\"`\n\tLine int    `json:\"line\"`\n}\n\n// Transformation holds information about a variable re-assignment.\ntype Transformation struct {\n\tFile string `json:\"file\"`\n\tLine int    `json:\"line\"`\n}\n\n// FunctionSymbol holds information about a function.\ntype FunctionSymbol struct {\n\tName      string       `json:\"name\"`\n\tStartLine int          `json:\"start_line\"`\n\tEndLine   int          `json:\"end_line\"`\n\tCalls     []CallDetail `json:\"calls\"`\n}\n\n// VariableSymbol holds variable information and its transformations.\ntype VariableSymbol struct {\n\tName            string           `json:\"name\"`\n\tDefinedAtLine   int              `json:\"defined_at_line\"`\n\tTransformations []Transformation `json:\"transformations\"`\n\tUsedInFiles     []string         `json:\"used_in_files\"`\n}\n\n// JSAnalysisReport holds the analysis report for a JS file.\ntype JSAnalysisReport struct {\n\tFile      string           `json:\"file\"`\n\tFunctions []FunctionSymbol `json:\"functions\"`\n\tVariables []VariableSymbol `json:\"variables\"`\n}\n\n// AnalyzeJSFile analyzes a JS file to extract functions and variable usages.\nfunc AnalyzeJSFile(filePath string) (*JSAnalysisReport, error) {\n\tcontent, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlines := regexp.MustCompile(\"\\r?\\n\").Split(string(content), -1)\n\n\t// First pass: collect all user-defined function names.\n\treFunc := regexp.MustCompile(`function\\s+(\\w+)\\s*\\(`)\n\tuserDefined := make(map[string]bool)\n\tfor _, line := range lines {\n\t\tif matches := reFunc.FindStringSubmatch(line); matches != nil {\n\t\t\tuserDefined[matches[1]] = true\n\t\t}\n\t}\n\n\tvar functions []FunctionSymbol\n\tvar variables []VariableSymbol\n\n\t// Regex for variable declarations (var, let, or const).\n\treVar := regexp.MustCompile(`(var|let|const)\\s+(\\w+)`)\n\tfor i, line := range lines {\n\t\t// Process function definitions.\n\t\tif matches := reFunc.FindStringSubmatch(line); matches != nil {\n\t\t\tfname := matches[1]\n\t\t\tfunctions = append(functions, FunctionSymbol{\n\t\t\t\tName:      fname,\n\t\t\t\tStartLine: i + 1,\n\t\t\t\tEndLine:   i + 1, // EndLine is a placeholder.\n\t\t\t\tCalls:     extractFunctionCalls(userDefined, fname, lines),\n\t\t\t})\n\t\t}\n\t\t// Process variable declarations.\n\t\tif matches := reVar.FindStringSubmatch(line); matches != nil {\n\t\t\tvname := matches[2]\n\t\t\tvariables = append(variables, VariableSymbol{\n\t\t\t\tName:            vname,\n\t\t\t\tDefinedAtLine:   i + 1,\n\t\t\t\tTransformations: extractVariableTransformations(filePath, vname, lines),\n\t\t\t\tUsedInFiles:     []string{}, // Populate with cross-file usage if needed.\n\t\t\t})\n\t\t}\n\t}\n\n\treport := \u0026JSAnalysisReport{\n\t\tFile:      filePath,\n\t\tFunctions: functions,\n\t\tVariables: variables,\n\t}\n\treturn report, nil\n}\n\n// extractFunctionCalls scans the file lines to extract call details from user-defined functions.\nfunc extractFunctionCalls(userDefined map[string]bool, currentFunc string, lines []string) []CallDetail {\n\tvar calls []CallDetail\n\treCall := regexp.MustCompile(`(\\w+)\\s*\\(`)\n\tfor i, line := range lines {\n\t\t// Find all potential call matches.\n\t\tmatches := reCall.FindAllStringSubmatch(line, -1)\n\t\tfor _, m := range matches {\n\t\t\tcallName := m[1]\n\t\t\t// Skip if the call is to itself or not in the user-defined map.\n\t\t\tif callName == currentFunc {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, exists := userDefined[callName]; !exists {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcalls = append(calls, CallDetail{\n\t\t\t\tName: callName,\n\t\t\t\tLine: i + 1,\n\t\t\t})\n\t\t}\n\t}\n\treturn calls\n}\n\n// extractVariableTransformations locates where a variable is re-assigned.\nfunc extractVariableTransformations(filePath, varName string, lines []string) []Transformation {\n\tvar transforms []Transformation\n\treAssign := regexp.MustCompile(varName + `\\s*=`)\n\tfor i, line := range lines {\n\t\tif reAssign.MatchString(line) {\n\t\t\ttransforms = append(transforms, Transformation{\n\t\t\t\tFile: filePath,\n\t\t\t\tLine: i + 1,\n\t\t\t})\n\t\t}\n\t}\n\treturn transforms\n}\n\n// SaveJSAnalysisReport writes a single-file analysis report to a JSON file.\nfunc SaveJSAnalysisReport(report *JSAnalysisReport, outputPath string) error {\n\tdata, err := json.MarshalIndent(report, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.WriteFile(outputPath, data, 0644)\n}\n\n// SaveJSAnalysisReports writes the aggregated analysis reports to a JSON file.\nfunc SaveJSAnalysisReports(reports []JSAnalysisReport, outputPath string) error {\n\tdata, err := json.MarshalIndent(reports, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.WriteFile(outputPath, data, 0644)\n}\n",
      "dependencies": [
        "encoding/json",
        "io/ioutil",
        "regexp"
      ]
    },
    {
      "id": 5,
      "name": "main.go",
      "category": "file",
      "path": "cgitrepo/goservice/main.go",
      "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tif len(os.Args) \u003c 2 {\n\t\tfmt.Println(\"Usage: graphdata \u003crepo-directory\u003e\")\n\t\tos.Exit(1)\n\t}\n\trepoDir := os.Args[1]\n\n\t// Detect languages used in the repository.\n\tlanguages, err := DetectLanguages(repoDir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error detecting languages: %v\", err)\n\t}\n\tfmt.Printf(\"Detected languages: %v\\n\", languages)\n\n\t// Find entry points based on the detected languages.\n\tfiles, err := FindEntryPoints(repoDir, languages)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error scanning directory: %v\", err)\n\t}\n\tif len(files) == 0 {\n\t\tlog.Fatal(\"No entry point files found in the provided directory.\")\n\t}\n\n\t// Read package.json dependencies if JavaScript is detected.\n\tvar pkgDeps map[string]bool\n\tif contains(languages, \"javascript\") {\n\t\tpkgDeps, err = ReadPackageJSON(repoDir)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Warning: could not parse package.json: %v\", err)\n\t\t}\n\t}\n\n\t// Build a dependency tree by scanning each file.\n\tdepTree := make(map[string][]string)\n\t// Accumulate JS analysis reports.\n\tvar jsReports []JSAnalysisReport\n\n\tfor _, file := range files {\n\t\tdeps, err := ScanDependencies(file)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error scanning %s: %v\", file, err)\n\t\t\tcontinue\n\t\t}\n\t\tdepTree[file] = deps\n\t\t// Optionally check import/export specifics.\n\t\tCheckImportsExports(file, languageForFile(file))\n\n\t\t// If the file is JavaScript, perform advanced analysis.\n\t\tif languageForFile(file) == \"javascript\" {\n\t\t\treport, err := AnalyzeJSFile(file)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error analyzing JS file %s: %v\", file, err)\n\t\t\t} else {\n\t\t\t\tjsReports = append(jsReports, *report)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Build the dependency graph.\n\tgraph, err := BuildGraph(depTree, pkgDeps)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error building graph: %v\", err)\n\t}\n\n\t// Save the dependency graph as JSON.\n\terr = SaveGraphData(\"graphdata.json\", graph)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error writing graph data: %v\", err)\n\t}\n\tfmt.Println(\"Graph data saved to graphdata.json\")\n\n\t// Save the aggregated JS analysis reports as JSON.\n\terr = SaveJSAnalysisReports(jsReports, \"js_analysis_data.json\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Error writing JS analysis data: %v\", err)\n\t}\n\tfmt.Println(\"JS analysis data saved to js_analysis_data.json\")\n}\n\nfunc contains(slice []string, str string) bool {\n\tfor _, s := range slice {\n\t\tif s == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc languageForFile(file string) string {\n\tif hasSuffix(file, \".js\") || hasSuffix(file, \".ts\") || hasSuffix(file, \".jsx\") || hasSuffix(file, \".tsx\") {\n\t\treturn \"javascript\"\n\t} else if hasSuffix(file, \".py\") {\n\t\treturn \"python\"\n\t} else if hasSuffix(file, \".go\") {\n\t\treturn \"go\"\n\t}\n\treturn \"unknown\"\n}\n",
      "dependencies": [
        "fmt",
        "log",
        "os"
      ]
    },
    {
      "id": 6,
      "name": "dependency_scanner.go",
      "category": "file",
      "path": "cgitrepo/goservice/dependency_scanner.go",
      "content": "package main\n\nimport \"errors\"\n\n// ScanDependencies chooses the appropriate scanner based on the file extension.\nfunc ScanDependencies(filePath string) ([]string, error) {\n    if hasSuffix(filePath, \".js\") ||\n        hasSuffix(filePath, \".ts\") ||\n        hasSuffix(filePath, \".jsx\") ||\n        hasSuffix(filePath, \".tsx\") {\n        return ScanJSScanner(filePath)\n    } else if hasSuffix(filePath, \".py\") {\n        return ScanPythonScanner(filePath)\n    } else if hasSuffix(filePath, \".go\") {\n        return ScanGoScanner(filePath)\n    }\n    return nil, errors.New(\"unsupported file type for dependency scanning\")\n}\n\n// hasSuffix is a helper function.\nfunc hasSuffix(path, suffix string) bool {\n    l := len(suffix)\n    if len(path) \u003c l {\n        return false\n    }\n    return path[len(path)-l:] == suffix\n}",
      "dependencies": [
        "errors"
      ]
    },
    {
      "id": 7,
      "name": "go_mod_scanner.go",
      "category": "file",
      "path": "cgitrepo/goservice/go_mod_scanner.go",
      "content": "package main\n\nimport (\n    \"bufio\"\n    \"os\"\n    \"regexp\"\n    \"strings\"\n)\n\n// ScanGoMod reads a go.mod file and returns a list of module dependencies.\nfunc ScanGoMod(modFilePath string) ([]string, error) {\n    file, err := os.Open(modFilePath)\n    if err != nil {\n        return nil, err\n    }\n    defer file.Close()\n\n    depMap := make(map[string]bool)\n    scanner := bufio.NewScanner(file)\n\n    // Regular expressions to match require lines.\n    requireRegex := regexp.MustCompile(`^require\\s+(?:\\()?([^ \\t\\n]+)`)\n    blockLineRegex := regexp.MustCompile(`^([^ \\t\\n]+)\\s+`)\n\n    inRequireBlock := false\n    for scanner.Scan() {\n        line := strings.TrimSpace(scanner.Text())\n        if strings.HasPrefix(line, \"require (\") {\n            inRequireBlock = true\n            continue\n        }\n        if inRequireBlock {\n            if line == \")\" {\n                inRequireBlock = false\n                continue\n            }\n            if matches := blockLineRegex.FindStringSubmatch(line); len(matches) \u003e 1 {\n                depMap[matches[1]] = true\n            }\n        } else {\n            if strings.HasPrefix(line, \"require\") {\n                if matches := requireRegex.FindStringSubmatch(line); len(matches) \u003e 1 {\n                    depMap[matches[1]] = true\n                }\n            }\n        }\n    }\n\n    if err := scanner.Err(); err != nil {\n        return nil, err\n    }\n\n    var deps []string\n    for dep := range depMap {\n        deps = append(deps, dep)\n    }\n    return deps, nil\n}",
      "dependencies": [
        "strings",
        "bufio",
        "os"
      ]
    },
    {
      "id": 8,
      "name": "javascript_scanner.go",
      "category": "file",
      "path": "cgitrepo/goservice/javascript_scanner.go",
      "content": "package main\n\nimport (\n    \"os\"\n    \"regexp\"\n    \"strings\"\n)\n\n// ScanJSScanner scans a JavaScript/TypeScript/JSX/TSX file for dependency strings.\nfunc ScanJSScanner(filePath string) ([]string, error) {\n    content, err := os.ReadFile(filePath)\n    if err != nil {\n        return nil, err\n    }\n    text := string(content)\n\n    // Match import statements.\n\treImportFrom := regexp.MustCompile(`(?m)import\\s+.*?\\s+from\\s+['\"]([^'\"]+)['\"]`)\n\treImportType := regexp.MustCompile(`(?m)import\\s+type.*?\\s+from\\s+['\"]([^'\"]+)['\"]`)\n\treImportOnly := regexp.MustCompile(`(?m)import\\s+['\"]([^'\"]+)['\"]`)\n\treRequire := regexp.MustCompile(`(?m)require\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)`)\n\t// Also capture static asset references like mp3, png, etc.\n\treAsset := regexp.MustCompile(`(?m)['\"]([^'\"]+\\.(?:mp3|png|jpg|jpeg|svg|gif))['\"]`)\n\t\n    depMap := make(map[string]bool)\n    extractDep := func(matches [][]string) {\n        for _, m := range matches {\n            dep := m[1]\n            // Skip relative imports.\n            if !strings.HasPrefix(dep, \".\") {\n                depMap[dep] = true\n            }\n        }\n    }\n\n    extractDep(reImportFrom.FindAllStringSubmatch(text, -1))\n    extractDep(reImportOnly.FindAllStringSubmatch(text, -1))\n    extractDep(reRequire.FindAllStringSubmatch(text, -1))\n    extractDep(reAsset.FindAllStringSubmatch(text, -1))\n\textractDep(reImportType.FindAllStringSubmatch(text, -1))\n\n    var deps []string\n    for dep := range depMap {\n        deps = append(deps, dep)\n    }\n    return deps, nil\n}",
      "dependencies": [
        "os",
        "regexp",
        "strings"
      ]
    },
    {
      "id": 9,
      "name": "lang_import_export.go",
      "category": "file",
      "path": "cgitrepo/goservice/lang_import_export.go",
      "content": "package main\n\nimport \"fmt\"\n\n// CheckImportsExports is a stub for language-specific validations.\nfunc CheckImportsExports(filePath string, language string) {\n    // This function can be expanded to check export/import correctness.\n    fmt.Printf(\"Checking import/export for language %s in %s\\n\", language, filePath)\n}",
      "dependencies": [
        "fmt"
      ]
    },
    {
      "id": 10,
      "name": "packagejson.go",
      "category": "file",
      "path": "cgitrepo/goservice/packagejson.go",
      "content": "package main\n\nimport (\n    \"encoding/json\"\n    \"io/ioutil\"\n    \"path/filepath\"\n)\n\ntype PackageJSON struct {\n    Dependencies    map[string]string `json:\"dependencies\"`\n    DevDependencies map[string]string `json:\"devDependencies\"`\n}\n\n// ReadPackageJSON reads and parses package.json and returns a map of dependency names.\nfunc ReadPackageJSON(repoDir string) (map[string]bool, error) {\n    pkgPath := filepath.Join(repoDir, \"package.json\")\n    content, err := ioutil.ReadFile(pkgPath)\n    if err != nil {\n        return nil, err\n    }\n    var pkg PackageJSON\n    err = json.Unmarshal(content, \u0026pkg)\n    if err != nil {\n        return nil, err\n    }\n    \n    deps := make(map[string]bool)\n    for dep := range pkg.Dependencies {\n        deps[dep] = true\n    }\n    for dep := range pkg.DevDependencies {\n        deps[dep] = true\n    }\n    \n    return deps, nil\n}",
      "dependencies": [
        "encoding/json",
        "io/ioutil",
        "path/filepath"
      ]
    },
    {
      "id": 11,
      "name": "io/fs",
      "category": "dependency"
    },
    {
      "id": 12,
      "name": "path/filepath",
      "category": "dependency"
    },
    {
      "id": 13,
      "name": "strings",
      "category": "dependency"
    },
    {
      "id": 14,
      "name": "package",
      "category": "dependency"
    },
    {
      "id": 15,
      "name": "regexp",
      "category": "dependency"
    },
    {
      "id": 16,
      "name": "os",
      "category": "dependency"
    },
    {
      "id": 17,
      "name": "encoding/json",
      "category": "dependency"
    },
    {
      "id": 18,
      "name": "io/ioutil",
      "category": "dependency"
    },
    {
      "id": 19,
      "name": "fmt",
      "category": "dependency"
    },
    {
      "id": 20,
      "name": "log",
      "category": "dependency"
    },
    {
      "id": 21,
      "name": "errors",
      "category": "dependency"
    },
    {
      "id": 22,
      "name": "bufio",
      "category": "dependency"
    }
  ],
  "links": [
    {
      "source": 6,
      "target": 21,
      "relation": "depends"
    },
    {
      "source": 7,
      "target": 13,
      "relation": "depends"
    },
    {
      "source": 7,
      "target": 22,
      "relation": "depends"
    },
    {
      "source": 7,
      "target": 16,
      "relation": "depends"
    },
    {
      "source": 8,
      "target": 16,
      "relation": "depends"
    },
    {
      "source": 8,
      "target": 15,
      "relation": "depends"
    },
    {
      "source": 8,
      "target": 13,
      "relation": "depends"
    },
    {
      "source": 9,
      "target": 19,
      "relation": "depends"
    },
    {
      "source": 10,
      "target": 17,
      "relation": "depends"
    },
    {
      "source": 10,
      "target": 18,
      "relation": "depends"
    },
    {
      "source": 10,
      "target": 12,
      "relation": "depends"
    },
    {
      "source": 0,
      "target": 16,
      "relation": "depends"
    },
    {
      "source": 0,
      "target": 15,
      "relation": "depends"
    },
    {
      "source": 1,
      "target": 11,
      "relation": "depends"
    },
    {
      "source": 1,
      "target": 12,
      "relation": "depends"
    },
    {
      "source": 1,
      "target": 13,
      "relation": "depends"
    },
    {
      "source": 2,
      "target": 14,
      "relation": "depends"
    },
    {
      "source": 2,
      "target": 15,
      "relation": "depends"
    },
    {
      "source": 2,
      "target": 16,
      "relation": "depends"
    },
    {
      "source": 3,
      "target": 17,
      "relation": "depends"
    },
    {
      "source": 3,
      "target": 16,
      "relation": "depends"
    },
    {
      "source": 3,
      "target": 12,
      "relation": "depends"
    },
    {
      "source": 4,
      "target": 17,
      "relation": "depends"
    },
    {
      "source": 4,
      "target": 18,
      "relation": "depends"
    },
    {
      "source": 4,
      "target": 15,
      "relation": "depends"
    },
    {
      "source": 5,
      "target": 19,
      "relation": "depends"
    },
    {
      "source": 5,
      "target": 20,
      "relation": "depends"
    },
    {
      "source": 5,
      "target": 16,
      "relation": "depends"
    }
  ],
  "language": "go"
}